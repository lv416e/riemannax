"""Lorentz/Hyperboloid model implementation for hyperbolic geometry.

This module implements the hyperboloid model of hyperbolic geometry, also known as
the Lorentz model. Points are represented on the forward sheet of a hyperboloid
in Minkowski space with the constraint x₀² - x₁² - ... - xₙ² = 1, x₀ > 0.

The hyperboloid model is often more numerically stable than the Poincaré ball
for optimization tasks due to linear operations in the embedding space.
"""

import jax
import jax.numpy as jnp
from jaxtyping import Array, Float

from riemannax.manifolds.base import Manifold, ManifoldPoint, PRNGKeyArray, TangentVector


class Lorentz(Manifold):
    """Lorentz/Hyperboloid model of n-dimensional hyperbolic geometry.

    The hyperboloid model represents hyperbolic space as the forward sheet of
    a two-sheeted hyperboloid in (n+1)-dimensional Minkowski space.
    Points satisfy the constraint: x₀² - x₁² - ... - xₙ² = 1 with x₀ > 0.

    This model is numerically stable for optimization as it uses linear operations
    in the embedding space, though it's limited to vectors with length < 19
    due to numerical precision of hyperbolic functions.

    Attributes:
        dimension: Dimension of the hyperbolic space.
        curvature: Sectional curvature (negative scalar).
        atol: Absolute tolerance for numerical computations.
    """

    def __init__(self, dimension: int, curvature: float = -1.0, atol: float = 1e-8) -> None:
        """Initialize the Lorentz hyperboloid model.

        Args:
            dimension: Dimension of the hyperbolic space.
            curvature: Sectional curvature (must be negative).
            atol: Absolute tolerance for validation and computations.

        Raises:
            ValueError: If dimension < 1 or curvature >= 0.
        """
        if dimension < 1:
            raise ValueError(f"Dimension must be positive, got {dimension}")
        if curvature >= 0:
            raise ValueError(f"Curvature must be negative for hyperbolic space, got {curvature}")

        super().__init__()
        self._dimension = dimension
        self.curvature = curvature
        self.atol = atol
        self.name = "Lorentz"

    @property
    def dimension(self) -> int:
        """Intrinsic dimension of the hyperbolic space."""
        return self._dimension

    @property
    def ambient_dimension(self) -> int:
        """Return ambient dimension of Minkowski space."""
        return self._dimension + 1

    def _minkowski_inner(self, u: Array, v: Array) -> Array:
        """Compute the Minkowski inner product between two vectors.

        The Minkowski bilinear form for vectors in R^(n+1):
        B(u,v) = u₀v₀ - u₁v₁ - u₂v₂ - ... - uₙvₙ

        This is the fundamental inner product for the hyperboloid model.

        Args:
            u: First vector in R^(n+1).
            v: Second vector in R^(n+1).

        Returns:
            Minkowski inner product scalar.
        """
        # Split into time and space components
        u_time, u_space = u[..., 0], u[..., 1:]
        v_time, v_space = v[..., 0], v[..., 1:]

        # Minkowski inner product: + for time, - for space (hyperboloid convention)
        return u_time * v_time - jnp.sum(u_space * v_space, axis=-1)

    def random_point(self, key: PRNGKeyArray, *shape: int) -> ManifoldPoint:
        """Generate random point(s) on the hyperboloid.

        Points are generated by sampling from a normal distribution and projecting
        onto the hyperboloid using the constraint x₀² - x₁² - ... - xₙ² = 1.

        Args:
            key: JAX PRNG key for random generation.
            *shape: Shape of the output array of points.

        Returns:
            Random point(s) on the hyperboloid with specified shape.
        """
        if not shape:
            target_shape: tuple[int, ...] = (self._dimension + 1,)
        else:
            target_shape = (*tuple(shape), self._dimension + 1)

        # Generate random spatial components (x₁, ..., xₙ)
        spatial_components = jax.random.normal(key, (*target_shape[:-1], self._dimension))

        # Compute the time component x₀ using hyperboloid constraint
        # x₀² - x₁² - ... - xₙ² = -1, so x₀² = x₁² + ... + xₙ² - 1
        # We need x₀² ≥ 0, so x₁² + ... + xₙ² ≥ 1
        spatial_norm_sq = jnp.sum(spatial_components**2, axis=-1, keepdims=True)
        # Ensure we have x₁² + ... + xₙ² ≥ 1 by adding a minimum of 1
        adjusted_spatial_norm_sq = spatial_norm_sq + 1.0
        time_component = jnp.sqrt(adjusted_spatial_norm_sq)

        # Combine time and space components
        point = jnp.concatenate([time_component, spatial_components], axis=-1)

        return point

    def random_tangent(self, key: PRNGKeyArray, x: ManifoldPoint, *shape: int) -> TangentVector:
        """Generate random tangent vector(s) at point x.

        Tangent vectors in the hyperboloid model must be orthogonal to the point x
        with respect to the Minkowski inner product: B(x, v) = 0.

        Args:
            key: JAX PRNG key for random generation.
            x: Base point on the hyperboloid.
            *shape: Shape of the output array of tangent vectors.

        Returns:
            Random tangent vector(s) at x with specified shape.
        """
        if not shape:
            target_shape: tuple[int, ...] = (self._dimension + 1,)
        else:
            target_shape = (*tuple(shape), self._dimension + 1)

        # Generate random vector
        v = jax.random.normal(key, target_shape)

        # Project to tangent space: v_tangent = v - B(x,v)/B(x,x) * x
        # Since B(x,x) = 1 for points on the hyperboloid, this becomes:
        # v_tangent = v - B(x,v) * x
        minkowski_prod = self._minkowski_inner(x, v)

        # Add dimensions for proper broadcasting
        # minkowski_prod has shape (...,), x has shape (..., n+1)
        # We need minkowski_prod to have shape (..., 1) to broadcast with x
        minkowski_prod = minkowski_prod[..., None]

        tangent = v - minkowski_prod * x

        return tangent

    def validate_point(self, x: ManifoldPoint, atol: float | None = None) -> bool | Array:
        """Validate that x is a valid point on the hyperboloid.

        Points must satisfy:
        1. The hyperboloid constraint: x₀² - x₁² - ... - xₙ² = 1
        2. The forward sheet condition: x₀ > 0

        Args:
            x: Point to validate.
            atol: Absolute tolerance (uses self.atol if None).

        Returns:
            True if x is a valid hyperboloid point, False otherwise.
        """
        if atol is None:
            atol = self.atol

        # Check hyperboloid constraint: should be 1
        minkowski_norm = self._minkowski_inner(x, x)
        constraint_satisfied = jnp.abs(minkowski_norm - 1.0) < atol

        # Check forward sheet condition
        forward_sheet = x[..., 0] > 0

        valid = constraint_satisfied & forward_sheet

        # Return JAX array directly if in traced context
        try:
            return bool(valid)
        except TypeError:
            return valid

    def validate_tangent(self, x: ManifoldPoint, v: TangentVector, atol: float | None = None) -> bool | Array:
        """Validate that v is a valid tangent vector at point x.

        Tangent vectors must be orthogonal to x with respect to the Minkowski
        inner product: B(x, v) = 0.

        Args:
            x: Base point on the hyperboloid.
            v: Vector to validate as tangent.
            atol: Absolute tolerance (uses self.atol if None).

        Returns:
            True if v is a valid tangent vector at x, False otherwise.
        """
        if atol is None:
            atol = self.atol

        # Check shape compatibility
        shape_compatible = x.shape == v.shape

        # Check orthogonality condition
        minkowski_prod = self._minkowski_inner(x, v)
        orthogonal = jnp.abs(minkowski_prod) < atol

        valid = shape_compatible & orthogonal

        # Return JAX array directly if in traced context
        try:
            return bool(valid)
        except TypeError:
            return valid

    def exp(self, x: ManifoldPoint, v: TangentVector) -> ManifoldPoint:
        """Exponential map from tangent space to manifold.

        Moves from point x in direction v (tangent vector) to reach a new point
        on the hyperboloid. Uses the hyperbolic geodesic formula.

        Args:
            x: Base point on hyperboloid.
            v: Tangent vector at x.

        Returns:
            Point on hyperboloid reached by following geodesic.
        """
        v_norm = jnp.sqrt(self.inner(x, v, v))

        # Handle zero vector case
        def zero_case():
            return x

        def nonzero_case():
            # Hyperbolic exponential: x * cosh(||v||) + (v/||v||) * sinh(||v||)
            v_normalized = v / v_norm[..., None]  # Broadcasting fix
            cosh_norm = jnp.cosh(v_norm)[..., None]  # Broadcasting fix
            sinh_norm = jnp.sinh(v_norm)[..., None]  # Broadcasting fix
            return x * cosh_norm + v_normalized * sinh_norm

        return jnp.where(v_norm[..., None] < 1e-10, zero_case(), nonzero_case())  # Broadcasting fix

    def log(self, x: ManifoldPoint, y: ManifoldPoint) -> TangentVector:
        """Logarithmic map from manifold to tangent space.

        Computes the tangent vector at x pointing towards y.

        Args:
            x: Base point on hyperboloid.
            y: Target point on hyperboloid.

        Returns:
            Tangent vector at x pointing towards y.
        """

        # Handle same point case
        def same_point_case():
            return jnp.zeros_like(x)

        def different_points_case():
            # Minkowski inner product
            minkowski_xy = self._minkowski_inner(x, y)

            # Clamp to handle numerical errors
            minkowski_xy = jnp.clip(minkowski_xy, 1.0 + 1e-15, jnp.inf)

            # Hyperbolic distance
            d = jnp.arccosh(minkowski_xy)

            # Direction vector: y - <x,y> * x (project y onto tangent space at x)
            direction = y - minkowski_xy[..., None] * x  # Broadcasting fix
            direction_norm = jnp.sqrt(-self._minkowski_inner(direction, direction))

            # Scale by distance
            return d[..., None] * direction / direction_norm[..., None]  # Broadcasting fix

        # Check if points are the same
        diff_norm = jnp.linalg.norm(x - y)
        return jnp.where(diff_norm < 1e-10, same_point_case(), different_points_case())

    def inner(self, x: ManifoldPoint, u: TangentVector, v: TangentVector) -> Array:
        """Riemannian inner product on tangent space.

        For the hyperboloid model, the Riemannian metric is inherited from
        the Minkowski metric but restricted to tangent vectors.

        Args:
            x: Base point on hyperboloid.
            u: First tangent vector at x.
            v: Second tangent vector at x.

        Returns:
            Inner product scalar.
        """
        # The Riemannian metric is the negative of the Minkowski inner product
        # when restricted to tangent vectors (which are spacelike)
        return -self._minkowski_inner(u, v)

    def dist(self, x: ManifoldPoint, y: ManifoldPoint) -> Array:
        """Distance between two points on the hyperboloid.

        Uses the hyperbolic distance formula based on the Minkowski inner product.

        Args:
            x: First point on hyperboloid.
            y: Second point on hyperboloid.

        Returns:
            Hyperbolic distance between x and y.
        """
        minkowski_xy = self._minkowski_inner(x, y)

        # Handle same point case more carefully
        def same_points():
            return 0.0

        def different_points():
            # Clamp to handle numerical errors (should be >= 1)
            clamped = jnp.clip(minkowski_xy, 1.0 + 1e-15, jnp.inf)
            return jnp.arccosh(clamped)

        # Check if points are essentially the same
        same = jnp.allclose(x, y, atol=1e-12)
        return jnp.where(same, same_points(), different_points())

    def retr(self, x: ManifoldPoint, v: TangentVector) -> ManifoldPoint:
        """Retraction operation (approximate exponential map).

        For the hyperboloid model, we use the exponential map as the retraction
        since it has a simple closed form.

        Args:
            x: Base point on hyperboloid.
            v: Tangent vector at x.

        Returns:
            Point on hyperboloid via retraction.
        """
        return self.exp(x, v)

    def proj(self, x: ManifoldPoint, v: Float[Array, "..."]) -> TangentVector:
        """Project vector v onto tangent space at point x.

        Args:
            x: Point on the manifold.
            v: Vector in ambient space to project.

        Returns:
            Projection of v onto tangent space at x.
        """
        # Tangent vectors must be orthogonal to x in Minkowski metric
        # proj_v = v - B(x, v) * x where B is Minkowski inner product
        minkowski_dot = self._minkowski_inner(x, v)
        return v - minkowski_dot[..., None] * x

    def proj_to_manifold(self, x: Array) -> ManifoldPoint:
        """Project point to hyperboloid manifold.

        Projects a point in ambient space to the closest point on the hyperboloid.

        Args:
            x: Point in ambient R^(n+1) space.

        Returns:
            Closest point on hyperboloid.
        """
        # Normalize to satisfy hyperboloid constraint
        minkowski_norm_sq = self._minkowski_inner(x, x)

        # Handle degenerate cases
        def handle_degenerate():
            # If norm is zero or negative, create a valid point
            result = jnp.zeros_like(x)
            result = result.at[0].set(1.0)  # Set time component to 1
            return result

        def project_normal():
            # Handle timelike vs spacelike vectors differently
            def project_timelike():
                # For timelike vectors (positive minkowski norm), scale normally
                scale = jnp.sqrt(1.0 / minkowski_norm_sq)
                projected = x * scale
                return jnp.where(projected[..., 0] > 0, projected, -projected)

            def project_spacelike():
                # For spacelike vectors (negative minkowski norm), we need special handling
                # Create a timelike vector by adjusting the time component
                spatial_norm_sq = jnp.sum(x[..., 1:] ** 2, axis=-1)
                new_time = jnp.sqrt(spatial_norm_sq + 1.0)

                # Construct projected point
                result = jnp.zeros_like(x)
                result = result.at[..., 0].set(new_time)
                result = result.at[..., 1:].set(x[..., 1:])
                return result

            # Choose projection method based on sign of Minkowski norm
            is_timelike = minkowski_norm_sq > 0
            return jnp.where(is_timelike, project_timelike(), project_spacelike())

        def already_on_manifold():
            # Ensure forward sheet
            return jnp.where(x[..., 0] > 0, x, -x)

        # Check different conditions
        is_degenerate = jnp.abs(minkowski_norm_sq) < 1e-15
        is_on_manifold = jnp.abs(minkowski_norm_sq - 1.0) < self.atol

        return jnp.where(
            is_degenerate, handle_degenerate(), jnp.where(is_on_manifold, already_on_manifold(), project_normal())
        )

    def transp(self, x: ManifoldPoint, y: ManifoldPoint, v: TangentVector) -> TangentVector:
        """Parallel transport tangent vector v from x to y along geodesic.

        Uses the exponential-logarithmic approach for parallel transport
        in the hyperboloid model of hyperbolic space.

        Args:
            x: Source point on hyperboloid.
            y: Target point on hyperboloid.
            v: Tangent vector at x to be transported.

        Returns:
            Parallel transported vector at y.
        """

        # Handle case when x and y are the same point
        def same_points():
            return v

        def different_points():
            # Get direction from x to y in tangent space at x
            log_xy = self.log(x, y)

            # Parallel transport formula for hyperboloid model
            # Uses the fact that parallel transport preserves the component
            # orthogonal to the geodesic direction

            # Inner product of v with geodesic direction
            v_parallel_component = self.inner(x, v, log_xy)
            log_norm_sq = self.inner(x, log_xy, log_xy)

            # Handle case where log_xy is zero (shouldn't happen but for safety)
            def non_zero_geodesic():
                # Coefficient for the parallel component
                coeff = v_parallel_component / log_norm_sq

                # Direction from y to x in tangent space at y
                log_yx = self.log(y, x)

                # Transport: orthogonal part stays + parallel part becomes log_yx direction
                orthogonal_part = v - coeff[..., None] * log_xy  # Broadcasting fix
                transported = orthogonal_part + coeff[..., None] * log_yx  # Broadcasting fix

                return transported

            def zero_geodesic():
                # If geodesic direction is zero, return original vector
                return v

            return jnp.where(
                log_norm_sq[..., None] < 1e-12,  # Broadcasting fix
                zero_geodesic(),
                non_zero_geodesic(),
            )

        # Check if points are the same
        same = jnp.allclose(x, y, atol=1e-12)
        return jnp.where(same, same_points(), different_points())

    def __repr__(self) -> str:
        """Return string representation of the Lorentz manifold."""
        return f"Lorentz(dim={self._dimension}, c={self.curvature})"
